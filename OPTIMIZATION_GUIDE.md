# Руководство по оптимизации производительности торгового ассистента

## Введение

Данный документ содержит пошаговое руководство по внедрению оптимизаций в торговый ассистент для QUIK. Оптимизации направлены на улучшение производительности, особенно при работе с большими объемами данных и частыми операциями.

## Внедрение оптимизаций

### 1. Замена функции получения информации об инструментах

#### Текущая реализация:
- В файле `Order.lua` в функции `GetSecurityInfo`

#### Оптимизированная реализация:
- Заменить на кэширующую версию из `optimized_functions.lua`
- Добавить вызов `ClearSecurityCache()` при необходимости сброса кэша

#### Пример внедрения:
```lua
-- В Order.lua заменить существующую функцию:
function GetSecurityInfo(securityCode)
  if security_cache[securityCode] then
    return security_cache[securityCode]
  end
  
  for classCode in string.gmatch("TQCB,TQBR,SPBXM,EQOB,TQIR,TQRD,TQOB,FQBR,TQTF,TQPI,MTQR,", "(%P*),") do
    local SecurityInfo = getSecurityInfo(classCode, securityCode)
    if SecurityInfo ~= nil then
      security_cache[securityCode] = SecurityInfo
      return SecurityInfo
    end
  end
  log.error("Инструмент не найден." .. securityCode)
  return nil
end
```

### 2. Оптимизация CSV-чтения

#### Текущая реализация:
- В файле `FileFunction.lua` в функции `getFromCSV`

#### Оптимизированная реализация:
- Заменить на версию с кэшированием
- Добавить проверку времени модификации файла

### 3. Оптимизация отправки ордеров

#### Текущая реализация:
- В файле `SubmittingOrders.lua` в функциях `SubmitOrders` и `IsSendOrder`

#### Оптимизированная реализация:
- Использовать индексированный подход для отслеживания отправленных ордеров
- Уменьшить количество повторных проверок

### 4. Оптимизация работы с таблицами

#### Текущая реализация:
- В файле `TableOrders.lua` в функции `RefreshTableOrdersControl`

#### Оптимизированная реализация:
- Использовать блокировку обновления UI при заполнении таблицы
- Создать индекс для быстрого поиска строк

## Постепенное внедрение

### Этап 1: Кэширование информации об инструментах
1. Добавить глобальные переменные для кэша
2. Заменить функцию `GetSecurityInfo`
3. Протестировать корректность работы

### Этап 2: Оптимизация CSV-чтения
1. Добавить кэширование файлов
2. Реализовать проверку времени модификации
3. Протестировать с разными размерами файлов

### Этап 3: Оптимизация отправки ордеров
1. Внедрить индекс отправленных ордеров
2. Заменить линейный поиск на индексированный
3. Проверить корректность обработки дубликатов

### Этап 4: Оптимизация таблиц
1. Добавить блокировку обновления UI
2. Создать индекс строк таблицы
3. Проверить визуальное отображение

## Тестирование оптимизаций

### Подготовка тестов
1. Создать тестовые CSV-файлы большого размера
2. Подготовить сценарии с высокой частотой операций
3. Настроить мониторинг производительности

### Метрики производительности
- Время загрузки CSV-файлов
- Время обработки ордеров
- Время обновления таблиц
- Использование памяти
- Частота вызовов API

### Проверка корректности
- Убедиться, что все функции работают как раньше
- Проверить обработку ошибок
- Проверить граничные случаи

## Возможные проблемы и решения

### 1. Проблемы с памятью при кэшировании
- **Проблема**: Кэши могут занимать много памяти
- **Решение**: Реализовать ограничение размера кэша или TTL для записей

### 2. Проблемы с синхронизацией данных
- **Проблема**: Кэшированные данные могут устаревать
- **Решение**: Добавить механизмы обновления кэша при изменении данных

### 3. Проблемы с производительностью в тестовой среде
- **Проблема**: Оптимизации могут не дать эффекта на малых объемах
- **Решение**: Тестировать на данных, близких к реальным

## Рекомендации по дальнейшей оптимизации

### 1. Асинхронная обработка
- Рассмотреть возможность использования таймеров для асинхронной обработки
- Разделить тяжелые операции на части

### 2. Пул соединений
- Оптимизировать использование API QUIK
- Кэшировать часто используемые параметры

### 3. Архитектурные изменения
- Рассмотреть возможность разделения на модули
- Оптимизировать структуру данных

## Заключение

Внедрение этих оптимизаций должно значительно улучшить производительность торгового ассистента, особенно при работе с большими объемами данных. Рекомендуется внедрять изменения постепенно и тщательно тестировать каждую оптимизацию.